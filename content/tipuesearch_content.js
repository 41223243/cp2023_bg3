var tipuesearch = {"pages": [{'title': 'About', 'text': ' https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': 'About.html'}, {'title': '組員倉儲列表', 'text': 'https://leeshaowei0716.github.io/cp2023/content/index.html \n https://41223243.github.io/cp2023/content/w5.html \n https://41223251.github.io/cp2023/content/index.html \n https://41223230.github.io/cp2023/content/index.html \n https://41223217.github.io/cp2023/content/index.html \n https://41223248.github.io/cp2023/content/index.html \n https://41223242.github.io/cp2023/content/index.html \n https://41223216.github.io/cp2023/content/index.html \n \n', 'tags': '', 'url': '組員倉儲列表.html'}, {'title': 'w2~3', 'text': '網路設定的部分 \n \n \n', 'tags': '', 'url': 'w2~3.html'}, {'title': 'w4~5', 'text': '在replit上執行gunplot。 \n \n // 包含標準輸出入程式庫的標頭文件{ pkgs }: \n// https://blog.csdn.net/weixin_38468077/article/details/101069365\n// http://www.gnuplot.info/demo/\n// https://github.com/sysprog21/rv32emu\n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3\n// https://cs61c.org/fa23/\n// https://greenteapress.com/wp/think-python-2e/\n// https://github.com/ecalvadi/c99-examples\n// https://github.com/gouravthakur39/beginners-C-program-examples\n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples\n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf\n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf\n// https://jsommers.github.io/cbook/cbook.pdf\n// https://jsommers.github.io/cbook/index.html\n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf\n// http://cslibrary.stanford.edu/101/EssentialC.pdf\n// https://publications.gbdirect.co.uk/c_book/\n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf\n// ***** execute on replit \n// cd downloads\n// cc gnuplot_ex1.c -o gnuplot_ex1\n// ./gnuplot_ex1\n#include <stdio.h>\n\n// 主函式\nint main() {\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n\n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal png font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/gnuplot_ex1.png\'\\n");\n    fprintf(gnuplotPipe, "plot sin(x)");\n    // Close popen\n    pclose(gnuplotPipe);\n\n    return 0;\n} \n 在Shell部分打上 \n cd downloads(改變至downloads檔案目錄) \n cc gunplot.c(cc是編譯器命令，用於編輯C語言) \n ./a.out \n 便會產生圖片 \n \n \n 注:影片中有部分解釋打錯pull更改為push \n \n', 'tags': '', 'url': 'w4~5.html'}, {'title': 'w6', 'text': '', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n  \nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue);\n  \nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = (int)(width*2.0 / 3.0);\n  \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n  \n    draw_roc_flag(img);\n  \n    FILE *outputFile = fopen("./roc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n  \nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    int sun_radius = (int)(width/8);\n  \n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    blue = gdImageColorAllocate(img, 0, 41, 204); // Blue\n  \n    // 繪製紅色矩形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n  \n    // 繪製藍色矩形區域\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n  \n    // 繪製太陽\n    draw_white_sun(img, center_x, center_y, sun_radius, white, red, blue);\n}\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue) {\n    float angle = 0;\n    int numRays = 12; // 光芒的數量\n  \n    gdPoint points[3]; // 三個頂點的陣列\n  \n    for (int i = 0; i < numRays; i++) {\n        angle = i * (2 * M_PI / numRays);\n        float x1 = center_x + cos(angle) * sun_radius;\n        float y1 = center_y + sin(angle) * sun_radius;\n  \n        // 調整兩個底邊頂點的位置\n      float x2 = center_x + cos(angle + 0.35) * (sun_radius * 0.5);\n      float y2 = center_y + sin(angle + 0.35) * (sun_radius * 0.5);\n      float x3 = center_x + cos(angle - 0.35) * (sun_radius * 0.5);\n      float y3 = center_y + sin(angle - 0.35) * (sun_radius * 0.5);\n  \n        // 設定多邊形的三個頂點\n        points[0].x = (int)x1;\n        points[0].y = (int)y1;\n        points[1].x = (int)x2;\n        points[1].y = (int)y2;\n        points[2].x = (int)x3;\n        points[2].y = (int)y3;\n  \n        gdImageFilledPolygon(img, points, 3, white);\n    }\n  //外圈\n  gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.2, sun_radius * 1.2, blue);\n    \n    // 繪製太陽內部\n    gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.1, sun_radius * 1.1, white);\n} \n \n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nint main() {\n    int width = 800;\n    int height = (int)(width / 1.9);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_usa_flag(img);\n\n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n}\n\nvoid draw_usa_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 国旗颜色\n    red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹\n    blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形\n\n    int stripe_height = height / 13;\n    int stripe_width = width;\n    int star_size = (int)(0.0308 * height); // 星星大小\n\n    for (int y = 0; y < height; y += stripe_height) {\n        if (y / stripe_height % 2 == 0) {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n        } else {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n        }\n    }\n\n    gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n\n    int star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距\n    int star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距\n    int star_start_x = (int)(0.125 * height); // 星星的起始X位置\n    int star_start_y = (int)(0.0485 * height); // 星星的起始Y位置\n\n    for (int row = 0; row < 9; row++) {\n        int starsPerRow = (row % 2 == 0) ? 6 : 5;\n\n        // 计算2、4、6和8排星星的偏移量\n        int offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0;\n\n        for (int star = 0; star < starsPerRow; star++) {\n            int x = star_start_x + star * star_spacing_x + offset_x;\n\n            // 旋转角度（以弧度为单位）\n            double rotation_angle = M_PI / 5; // 忘記多少度的旋转\n\n            int y = star_start_y + row * star_spacing_y;\n            draw_star(img, x, y, star_size, white, rotation_angle);\n        }\n    }\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n\n    for (int i = 0; i < 10; i++) {\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;\n        int radius = (i % 2 == 0) ? size : size / 2;\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y + radius * sin(angle);\n    }\n\n    // 用指定的颜色填充星星\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <stdlib.h>\n \nvoid drawJapaneseFlag() {\n    int width = 300;   // 寬度\n    int height = 200;  // 高度\n    int radius = 50;   // 圓圈半徑\n    int centerX = 150; // 圓圈中心X座標\n    int centerY = 100; // 圓圈中心Y座標\n \n    // 創建一個 24 位的彩色圖片\n    gdImagePtr im = gdImageCreateTrueColor(width, height);\n \n    // 設置背景色為白色\n    int white = gdImageColorAllocate(im, 255, 255, 255);\n    gdImageFill(im, 0, 0, white);\n \n    // 設置圓圈的顏色為紅色\n    int red = gdImageColorAllocate(im, 255, 0, 0);\n \n    // 畫紅色圓圈\n    gdImageFilledEllipse(im, centerX, centerY, 2 * radius, 2 * radius, red);\n \n    // 輸出圖片到檔案\n    FILE *output = fopen("japanese_flag.png", "wb");\n    if (output == NULL) {\n        fprintf(stderr, "Unable to open file for writing.\\n");\n        exit(EXIT_FAILURE);\n    }\n \n    gdImagePng(im, output);\n \n    // 釋放內存\n    gdImageDestroy(im);\n    fclose(output);\n}\n \nint main() {\n    drawJapaneseFlag();\n    printf("Japanese flag created: japanese_flag.png\\n");\n    return 0;\n} \n \n \n #include <stdio.h>\n  #include <gd.h>\n  #include <math.h>\n \n  void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n  void draw_chinese_flag(gdImagePtr img);\n \n  int main() {\n      int width = 300; // 國旗寬度\n      int height = 200; // 國旗高度\n \n      gdImagePtr im = gdImageCreateTrueColor(width, height);\n      gdImageAlphaBlending(im, 0);\n \n      draw_chinese_flag(im);\n \n      FILE *outputFile = fopen("./../images/proc_flag.png", "wb");\n      if (outputFile == NULL) {\n          fprintf(stderr, "打開輸出文件時出錯。\\n");\n          return 1;\n      }\n \n      gdImagePngEx(im, outputFile, 9);\n      fclose(outputFile);\n      gdImageDestroy(im);\n \n      return 0;\n  }\n \n  void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n      gdPoint points[10];\n \n      double outer_radius = size / 2;\n      double inner_radius = size / 6;\n      double angle = M_PI / 5.0;\n \n      for (int i = 0; i < 10; i++) {\n          double radius = (i % 2 == 0) ? outer_radius : inner_radius;\n          double theta = rotation_angle + i * angle;\n          points[i].x = x + radius * cos(theta);\n          points[i].y = y + radius * sin(theta);\n      }\n \n      gdImageFilledPolygon(img, points, 10, color);\n  }\n \n  void draw_chinese_flag(gdImagePtr img) {\n      int width = gdImageSX(img);\n      int height = gdImageSY(img);\n      int red, yellow;\n \n      red = gdImageColorAllocate(img, 255, 0, 0); // 紅色背景\n      yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色星星\n \n      gdImageFilledRectangle(img, 0, 0, width, height, red);\n \n      int star_size = (int)(0.28 * height);\n      int star_x = (int)(0.165 * width);\n      int star_y = (int)(0.265 * height);\n \n      draw_star(img, star_x, star_y, star_size, yellow, 11.0);\n \n      double radius = 0.15 * height;\n      double angle = 360 / 7 * M_PI / 179.0;\n      double rotation = -M_PI / 7.5;\n      int cx = (int)(0.32 * width);\n      int cy = (int)(0.27 * height);\n \n      for (int i = -1; i < 3; i++) {\n          int x = (int)(cx + radius * cos(i * angle + rotation));\n          int y = (int)(cy + radius * sin(i * angle + rotation));\n          draw_star(img, x, y, 19, yellow, M_PI / 5.0);\n      }\n  } \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_uk_flag(gdImagePtr img);\nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color);\n \nint main() {\n    int width = 1200;\n    int height = width / 2;\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    draw_uk_flag(img);\n \n    FILE *outputFile = fopen("./../images/uk_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打開輸出文件時發生錯誤。\\n");\n        return 1;\n    }\n \n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n \n    return 0;\n}\n \nvoid draw_uk_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n \n    int red, white, blue;\n    red = gdImageColorAllocate(img, 204, 0, 0);\n    white = gdImageColorAllocate(img, 255, 255, 255);\n    blue = gdImageColorAllocate(img, 0, 0, 153);\n \n    gdImageFilledRectangle(img, 0, 0, width, height, blue);\n \n    // 繪製斜線\n    {\n        int line_thickness = 100;\n        gdImageSetThickness(img, line_thickness);\n \n        // 繪製白色斜線\n        int x1 = 0, y1 = 600, x2 = 1200, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, white);\n \n        x1 = 0, y1 = 0, x2 = 1200, y2 = 600;\n        gdImageLine(img, x1, y1, x2, y2, white);\n    }\n \n    // 繪製紅色斜線\n    {\n        int line_thickness = 33;\n        gdImageSetThickness(img, line_thickness);\n \n        // 繪製紅色斜線\n        int x1 = 566, y1 = 300, x2 = 1166, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n \n        x1 = 1233, y1 = 600, x2 = 633, y2 = 300;\n        gdImageLine(img, x1, y1, x2, y2, red);\n \n        x1 = 566, y1 = 300, x2 = -33, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n \n        x1 = 600, y1 = 316.5, x2 = 0, y2 = 616.5;\n        gdImageLine(img, x1, y1, x2, y2, red);\n    }\n \n    // 繪製白色斜線\n    {\n        int line_thickness = 33;\n        gdImageSetThickness(img, line_thickness);\n \n        // 繪製斜線\n        int x1 = 0, y1 = 600, x2 = 1200, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n \n        x1 = 1200, y1 = 16.5, x2 = 600, y2 = 316.5;\n        gdImageLine(img, x1, y1, x2, y2, white);\n \n        x1 = 0, y1 = 583.5, x2 = 600, y2 = 283.5;\n        gdImageLine(img, x1, y1, x2, y2, white);\n    }\n \n    // 繪製白色十字\n    int cross_width = width / 32;\n    int cross_arm_width = width / 32;\n    int center_x = width / 2;\n    int center_y = height / 2;\n \n    gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white);\n    gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white);\n \n    // 繪製紅色十字\n    gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);\n    gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red);\n} \n \n #include <gd.h>\n#include <stdio.h>\n#include <math.h>\n \nint main() {\n    gdImagePtr im;\n    FILE *output;\n    int white, red, blue, black;\n \n    im = gdImageCreateTrueColor(600, 400);\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    red = gdImageColorAllocate(im, 225, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 0, 225);\n    black = gdImageColorAllocate(im, 0, 0, 0);\n \n    // 填充白色背景\n    gdImageFilledRectangle(im, 0, 0, 599, 399, white);\n \n    // 在中間添加紅藍各一半的圓，將紅色移到上方，藍色移到下方\n    int centerX = 300;\n    int centerY = 200;\n    int radius = 200;\n \n    gdImageFilledArc(im, centerX, centerY, radius, radius, 0, 180, blue, gdPie);\n    gdImageFilledArc(im, centerX, centerY - 1, radius, radius, 180, 360, red, gdPie);\n \n    // 在中間添加向右偏移49的直徑為100的藍色圓\n    int blueCircleRadius = 50; // 半徑為50\n    int offsetX = 49;\n    gdImageFilledEllipse(im, centerX + offsetX, centerY, blueCircleRadius * 2, blueCircleRadius * 2, blue);\n \n    // 在中間添加向左偏移50的直徑為100的紅色圓\n    int redCircleRadius = 50; // 半徑為50\n    gdImageFilledEllipse(im, centerX - 49, centerY, redCircleRadius * 2, redCircleRadius * 2, red);\n \n    // 將中間的圖形順時針旋轉104度\n    double angle = 104.0;\n    gdImagePtr rotated_im = gdImageCreateTrueColor(600, 400);\n    gdImageFilledRectangle(rotated_im, 0, 0, 599, 399, white);\n \n    // 複製原始圖像\n    gdImageCopy(rotated_im, im, 0, 0, 0, 0, 600, 400);\n \n    // 逆時針旋轉的角度\n    double rotationAngle = 25.0; \n \n    // 繪製斜直的長方形\n    int rectWidth = 15;   // 長方形寬度\n    int rectHeight = 120;  // 長方形高度\n    int rectSpacing = 10;  // 長方形間隔\n \n    // 計算三個長方形的左上角座標\n    int rect1X = 139 - rectWidth - rectSpacing;  // 第一個長方形\n    int rect1Y = 206 - rectHeight / 2;\n    int rect2X = rect1X - rectWidth - rectSpacing;  // 第二個長方形\n    int rect2Y = rect1Y;\n    int rect3X = rect2X - rectWidth - rectSpacing;  // 第三個長方形\n    int rect3Y = rect1Y;\n \n    gdPoint points1[4];\n    points1[0].x = (int)(rect1X - centerX) * cos(rotationAngle * M_PI / 180) - (rect1Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[0].y = (int)(rect1X - centerX) * sin(rotationAngle * M_PI / 180) + (rect1Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[1].x = (int)((rect1X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect1Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[1].y = (int)((rect1X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect1Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[2].x = (int)((rect1X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect1Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[2].y = (int)((rect1X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect1Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[3].x = (int)(rect1X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect1Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[3].y = (int)(rect1X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect1Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n    gdPoint points2[4];\n    points2[0].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - (rect2Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[0].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + (rect2Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[1].x = (int)((rect2X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect2Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[1].y = (int)((rect2X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect2Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[2].x = (int)((rect2X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect2Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[2].y = (int)((rect2X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect2Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[3].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect2Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[3].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect2Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n    gdPoint points3[4];\n    points3[0].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[0].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[1].x = (int)((rect3X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[1].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[2].x = (int)((rect3X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect3Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[2].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[3].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect3Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[3].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n    gdImageFilledPolygon(rotated_im, points1, 4, black);\n    gdImageFilledPolygon(rotated_im, points2, 4, black);\n    gdImageFilledPolygon(rotated_im, points3, 4, black);\n \n \n  {// 添加新的黑色斜形\n  gdPoint rect4Points[4];\n  int rect4X = 70;  // 第四個長方形\n  int rect4Y = 185;\n  rect4Points[0].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[0].y = (int)(rect4X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  int rect4Width = rectWidth;  // 假設 rectWidth 已經定義\n  int rect4Height = rectHeight;  // 假設 rectHeight 已經定義\n  rect4Points[1].x = (int)((rect4X + rect4Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[1].y = (int)((rect4X + rect4Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4Points[2].x = (int)((rect4X + rect4Width) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4Y + rect4Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[2].y = (int)((rect4X + rect4Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4Y + rect4Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4Points[3].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4Y + rect4Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[3].y = (int)(rect4X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4Y + rect4Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect4Points, 4, black);\n \n  // 修改第五個斜形\n  gdPoint rect5Points[4];\n  int rect5X = rect4X + rect4Width + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4Y;\n  int middleRectWidth = 15;    // 中間長方形寬度\n  int middleRectHeight = 55;   // 中間長方形高度\n  int middleRectSpacing = 10;  // 中間長方形上下間隔\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n \n  // 添加位於第五個斜形下方的新的黑色斜形\n  gdPoint rectBelow5Points[4];\n  int rectBelow5X = rect5X;\n  int rectBelow5Y = rect5Y + middleRectHeight + middleRectSpacing;\n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, black);\n \n  // 添加新的黑色斜形\n  gdPoint rect6Points[4];\n  int rect6X = rect5X + middleRectWidth + rectSpacing;  // 第六個長方形\n  int rect6Y = rect4Y;\n  rect6Points[0].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[0].y = (int)(rect6X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  int rect6Width = rectWidth;  // 假設 rectWidth 已經定義\n  int rect6Height = rectHeight;  // 假設 rectHeight 已經定義\n  rect6Points[1].x = (int)((rect6X + rect6Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[1].y = (int)((rect6X + rect6Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6Points[2].x = (int)((rect6X + rect6Width) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6Y + rect6Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[2].y = (int)((rect6X + rect6Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6Y + rect6Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6Points[3].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6Y + rect6Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[3].y = (int)(rect6X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6Y + rect6Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect6Points, 4, black);}\n \n  {// 添加新的黑色斜形（第四個，上半部分）\n  gdPoint rect4aPoints[4];\n  int rect4aX = 460;  // 第四個長方形（上半部分）\n  int rect4aY = 139;\n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[0].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[3].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, black);\n \n  // 添加新的黑色斜形（第四個，下半部分）\n  gdPoint rect4bPoints[4];\n  int rect4bX = 460;  // 第四個長方形（下半部分）\n  int rect4bY = 139 + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[0].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[3].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, black);\n \n  // 修改第五個斜形（長度為 120）\n  gdPoint rect5Points[4];\n  int rect5X = rect4aX + 15 + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4aY;\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n \n  // 添加新的黑色斜形（第六個，上半部分）\n  gdPoint rect6aPoints[4];\n  int rect6aX = rect5X + 15 + rectSpacing;  // 第六個長方形（上半部分）\n  int rect6aY = rect5Y;\n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[0].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[3].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, black);\n \n  // 添加新的黑色斜形（第六個，下半部分）\n  gdPoint rect6bPoints[4];\n  int rect6bX = rect5X + 15 + rectSpacing;  // 第六個長方形（下半部分）\n  int rect6bY = rect5Y + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[0].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[3].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, black);}\n \n \n  // 添加新的黑色斜形（第四個，上半部分）\n  gdPoint rect4aPoints[4];\n  int rect4aX = 460;  // 第四個長方形（上半部分）\n  int rect4aY =185;\n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[0].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[3].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, black);\n \n  // 添加新的黑色斜形（第四個，下半部分）\n  gdPoint rect4bPoints[4];\n  int rect4bX = rect4aX;  // 使用与上半部分相同的X坐标\n  int rect4bY = rect4aY + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[0].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[3].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, black);\n \n  // 修改第五個斜形（在上方添加）\n  gdPoint rect5Points[4];\n  int rect5X = rect4aX + 15 + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4aY;\n  int middleRectWidth = 15;    // 中間長方形寬度\n  int middleRectHeight = 55;   // 中間長方形高度\n  int middleRectSpacing = 10;  // 中間長方形上下間隔\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n \n \n  // 添加位於第五個斜形下方的新的黑色斜形\n  gdPoint rectBelow5Points[4];\n  int rectBelow5X = rect5X;\n  int rectBelow5Y = rect5Y + middleRectHeight + middleRectSpacing;\n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, black);\n \n  // 第六個斜形（上半部分）\n  gdPoint rect6aPoints[4];\n  int rect6aX = rect5X + 15 + 10;  // 第六個長方形（上半部分）\n  int rect6aY = rect5Y;\n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[0].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[3].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, black);\n \n  // 第六個斜形（下半部分）\n  gdPoint rect6bPoints[4];\n  int rect6bX = rect6aX;  // 第六個長方形（下半部分）\n  int rect6bY = rect6aY + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[0].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[3].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n \n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, black);\n \n    output = fopen("output.png", "wb");\n    gdImagePng(rotated_im, output);\n    fclose(output);\n \n    gdImageDestroy(im);\n    gdImageDestroy(rotated_im);\n \n    return 0;\n} \n \n', 'tags': '', 'url': 'w8.html'}, {'title': 'w10', 'text': '\n', 'tags': '', 'url': 'w10.html'}, {'title': 'w11-12', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \n// Declare the rotation function\nvoid rotateFilledPolygon(int x_orig, int y_orig, double rotation_ang, gdPoint *points, int num_points) {\n    int i;\n    double angle_rad = rotation_ang * M_PI / 180.0;\n \n    for (i = 0; i < num_points; i++) {\n        int x = points[i].x - x_orig;\n        int y = points[i].y - y_orig;\n \n        points[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));\n        points[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));\n    }\n}\n \nint main() {\n    // Image dimensions\n    int width = 800;\n    int height = 600;\n \n    // Create a true-color image\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    // Open the output file\n    FILE *outputFile = fopen("hellogd1.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n \n    // Define color indices\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n \n    // Draw filled rectangles, ellipse, line, and polygons\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width / 4, (int)height / 4, blue);\n \n    gdImageFilledEllipse(img, (int)width * 3 / 4, (int)height / 4, (int)width / 4, (int)width / 4, red);\n    gdImageEllipse(img, (int)width * 3 / 4, (int)height * 3 / 4, (int)width / 4, (int)width / 4, red);\n    gdImageLine(img, (int)width / 2, (int)height / 2, (int)width / 2, (int)height / 2 + 100, blue);\n \n    gdPoint points[4] = {\n        { (int)width / 4, (int)height * 3 / 4 },\n        { (int)width / 4 + 100, (int)height * 3 / 4 },\n        { (int)width / 4 + 100, (int)height * 3 / 4 + 100 },\n        { (int)width / 4, (int)height * 3 / 4 + 100 }\n    };\n \n    // Call the rotation function for the first polygon\n    rotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 45.0, points, 4);\n    gdImagePolygon(img, points, 4, black);\n \n    gdPoint points2[4] = {\n        { (int)width / 3, (int)height / 2 },\n        { (int)width / 3 + 100, (int)height / 2 },\n        { (int)width / 3 + 100, (int)height / 2 + 100 },\n        { (int)width / 3 - 50, (int)height / 2 + 100 }\n    };\n \n    // Call the rotation function for the second polygon\n    rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0, points2, 4);\n    gdImageFilledPolygon(img, points2, 4, red);\n \n    // Save the image to the output file\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n \n    // Free the memory used by the image\n    gdImageDestroy(img);\n \n    return 0;\n} \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Declare the rotation function\nvoid rotateFilledPolygon(int x_orig, int y_orig, double rotation_ang, gdPoint *points, int num_points) {\n    int i;\n    double angle_rad = rotation_ang * M_PI / 180.0;\n\n    for (i = 0; i < num_points; i++) {\n        int x = points[i].x - x_orig;\n        int y = points[i].y - y_orig;\n\n        points[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));\n        points[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));\n    }\n}\n\nint main() {\n    int width = 800;\n    int height = 600;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    FILE *outputFile = fopen("hellogd2.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width / 4, (int)height / 4, blue);\n\n    gdImageFilledEllipse(img, (int)width * 3 / 4, (int)height / 4, (int)width / 4, (int)width / 4, red);\n    gdImageEllipse(img, (int)width * 3 / 4, (int)height * 3 / 4, (int)width / 4, (int)width / 4, red);\n    gdImageLine(img, (int)width / 2, (int)height / 2, (int)width / 2, (int)height / 2 + 100, blue);\n\n    gdPoint points[4];\n    points[0].x = (int)width / 4;\n    points[0].y = (int)height * 3 / 4;\n    points[1].x = points[0].x + 100;\n    points[1].y = points[0].y;\n    points[2].x = points[1].x;\n    points[2].y = points[1].y + 100;\n    points[3].x = points[2].x - 100;\n    points[3].y = points[2].y;\n\n    // Call the rotation function multiple times\n    for (int i = 0; i < 4; i++) {\n        rotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 30.0, points, 4);\n        gdImagePolygon(img, points, 4, black);\n    }\n\n    gdPoint points2[4];\n    points2[0].x = (int)width / 3;\n    points2[0].y = (int)height / 2;\n    points2[1].x = points2[0].x + 100;\n    points2[1].y = points2[0].y;\n    points2[2].x = points2[1].x;\n    points2[2].y = points2[1].y + 100;\n    points2[3].x = points2[2].x - 150;\n    points2[3].y = points2[2].y;\n\n    // Call the rotation function multiple times\n    for (int i = 0; i < 12; i++) {\n        //rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0, points2, 4);\n        rotateFilledPolygon(500, 200, 30.0, points2, 4);\n        gdImageFilledPolygon(img, points2, 4, red);\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n} \n \n 先設定hello.c的檔 \n   #include <stdio.h>\n \nint main()\n{\n    printf("hello world\\n");\n} \n 然後再shell打cc hello.c會出現這個 \n \n 然後要回車這樣replit就會幫我準備好c \n 之後再進行一次程式 cc hello.c，然後打./a.out \n 然後就會出現hello world \n', 'tags': '', 'url': 'w11-12.html'}, {'title': 'w16', 'text': '\n', 'tags': '', 'url': 'w16.html'}, {'title': 'c_EX', 'text': '', 'tags': '', 'url': 'c_EX.html'}, {'title': '課程1', 'text': '\n \n 1. \n #include <stdio.h>\n \nint main()\n{\nfloat a = 0.5;\ndouble b = 1.2;\nint c = 3;\nb = b + a + c;\n \n/* 输出 a, b, c 到屏幕 */\nprintf("a = %3.1f, b = %3.1f, c = %d\\n", a, b, c);\n \nreturn 0;\n} \n \n 2. \n /* ====================\n   字元範例 1\n   ==================== */\n#include <stdio.h>\n \nint main()\n{\n    char x, y;\n \n    x = \'a\';\n    y = (char)97;\n \n    /* 輸出 x, y, x, 最後一個是以 ASCII 值顯示 y */\n    printf("x = %c, y = %c, ASCII of y = %d", x, y, y);\n \n    return 0;\n}\n \n \n 3. \n #include <stdio.h>\n \nint main()\n{\n    int a = 64;\n    int b = 0x40; // 以十六进制表示\n    long c = 64L;\n \n    // 打印变量的值\n    printf("%d, %d, %ld", a, b, c);\n \n    return 0;\n} \n \n 4. \n \n #include <stdio.h> \n \xa0 \n int   main() \n { \n \xa0\xa0\xa0\xa0 int   a = 10, b = 5; \n \xa0 \n \xa0\xa0\xa0\xa0 // 第一组比较 \n \xa0\xa0\xa0\xa0 printf ( "a == b is %d\\n" , a == b); \n \xa0\xa0\xa0\xa0 printf ( "a > b is %d\\n" , a > b); \n \xa0\xa0\xa0\xa0 printf ( "a < b is %d\\n" , a < b); \n \xa0\xa0\xa0\xa0 printf ( "a >= b is %d\\n" , a >= b); \n \xa0\xa0\xa0\xa0 printf ( "a <= b is %d\\n" , a <= b); \n \xa0\xa0\xa0\xa0 printf ( "a != b is %d\\n" , a != b); \n \xa0 \n \xa0\xa0\xa0\xa0 printf ( "\\n" ); \n \xa0 \n \xa0\xa0\xa0\xa0 // 修改 b 的值 \n \xa0\xa0\xa0\xa0 b = 10; \n \xa0 \n \xa0\xa0\xa0\xa0 // 第二组比较 \n \xa0\xa0\xa0\xa0 printf ( "a == b is %d\\n" , a == b); \n \xa0\xa0\xa0\xa0 printf ( "a > b is %d\\n" , a > b); \n \xa0\xa0\xa0\xa0 printf ( "a < b is %d\\n" , a < b); \n \xa0\xa0\xa0\xa0 printf ( "a >= b is %d\\n" , a >= b); \n \xa0\xa0\xa0\xa0 printf ( "a <= b is %d\\n" , a <= b); \n \xa0\xa0\xa0\xa0 printf ( "a != b is %d\\n" , a != b); \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n \n 5. \n #include <stdio.h>\n \nvoid main()\n{\nint a;\n \n// 第一次输出\na = 3;\nprintf("%d\\n", !a); // 逻辑非运算，a为真，所以输出0\n \n// 第二次输出\na = 0;\nprintf("%d\\n", !a); // 逻辑非运算，a为假，所以输出1\n} \n \n 6. \n \n \n #include <stdio.h>\n \nvoid main()\n{\n    char a;\n \n    // 使用 %zu 格式说明符输出 size_t 类型\n    printf("The size of int is %zu\\n", sizeof(int));\n \n    // 使用 %zu 格式说明符输出 size_t 类型\n    printf("The size of char a is %zu\\n", sizeof(a));\n}\n \n \n \n \n 7. \n #include <stdio.h>\n \n/* ====================\n计算长方形面积, 需传入长与宽.\n==================== */\nint rect(int x, int y)\n{\n    int result;\n    result = x * y;\n    return result; /* 返回 result */\n}\n \n/* ====================\n主函数\n==================== */\nint main()\n{\n    int x = 8, y = 4;\n    int a;\n    a = rect(x, y);\n    printf("8*4 的面积是 %d", a);\n    return 0;\n} \n \n 8. \n #include <stdio.h>\nfloat circle( int r ); /* 宣告 circle 的 prototype */\nvoid main()\n{\nfloat answer;\nanswer = circle(8);\nprintf( " 圓周長度是 %f", answer );\n}\n/* ====================\n circle 函數, 計算 circle 的圓周長\n==================== */\nfloat circle( int r )\n{\nfloat result;\nresult = 3.14159 * (double)1001 * r;\nreturn ( result );\n} \n \n 9. \n #include <stdio.h>\n \nint main()\n{\n    char ch;\n \n    printf("输入一个字符：");\n \n    // 检查 scanf 的返回值，确保成功读取一个字符\n    if (scanf(" %c", &ch) != 1) {\n        printf("读取字符失败\\n");\n        return 1; // 或者采取其他错误处理措施\n    }\n \n    if (ch == \'a\') {\n        printf("您按下了 \'a\'\\n");\n    }\n \n    return 0;\n} \n \n \n 10. \n #include <stdio.h>\n \nvoid main()\n{\n    int i;\n \n    // 提示用户输入一个整数\n    printf("100：");\n \n    // 读取用户输入的整数\n    scanf("%d", &i);\n \n    // 判断输入的整数，并输出相应的消息\n    if (i < 100)\n    {\n        printf("i < 100\\n");\n    }\n    else\n    {\n        if ((i >= 100) && (i < 200))\n        {\n            printf("i >= 100 且 i < 200\\n");\n        }\n        else\n        {\n            printf("i >= 200\\n");\n        }\n    }\n} \n \n', 'tags': '', 'url': '課程1.html'}, {'title': '練習1', 'text': '', 'tags': '', 'url': '練習1.html'}, {'title': 'ANSIC', 'text': '', 'tags': '', 'url': 'ANSIC.html'}, {'title': '課程2', 'text': '1. \n #include <stdio.h>\n#include <string.h>\n \nint main() {\n    int n, x = 0;\n \n    printf("\\n\\n Check whether a given number is an ugly number:\\n");\n    printf("----------------------------------------------------\\n");\n \n    // 检查 scanf 的返回值\n    if (scanf("%d", &n) != 1) {\n        printf("Input is not a valid integer.\\n");\n        return 1;  // 退出程序，表示出现错误\n    }\n \n    if (n <= 0) {\n        printf("Input a correct number.\\n");\n    } else {\n        while (n != 1) {\n            if (n % 5 == 0) {\n                n /= 5;\n            } else if (n % 3 == 0) {\n                n /= 3;\n            } else if (n % 2 == 0) {\n                n /= 2;\n            } else {\n                printf("It is not an ugly number.\\n");\n                x = 1;\n                break;\n            }\n        }\n \n        if (x == 0) {\n            printf("It is an ugly number.\\n");\n        }\n    }\n \n    return 0;\n} \n \n \n \n \n 2. \n #include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    time_t epoch = 0;\n \n    printf("\\n自纪元开始以来的秒数：%ld\\n", (long)epoch);\n    printf("对应的日期和时间：%s\\n", asctime(gmtime(&epoch)));\n \n    return 0;\n} \n \n \n \n 3. \n #define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    time_t t = time(NULL);\n    printf("\\nThe calendar time expressed as a local Time is :");   \n    printf("\\nUTC:   %s", asctime(gmtime(&t)));\n    printf("local: %s\\n", asctime(localtime(&t)));\n \n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n \n    asctime_s(str, sizeof str, gmtime_s(&t, &buf));\n    printf("UTC:   %s", str);\n \n    asctime_s(str, sizeof str, localtime_s(&t, &buf));\n    printf("local: %s", str);\n#endif\n \n    return 0;\n} \n \n \n \n 4. \n #include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n \nint main(void)\n{\n    // 设置时区为“Asia/Calcutta”\n    setenv("TZ", "/usr/share/zoneinfo/Asia/Calcutta", 1);   \n \n    // 获取并打印当前日期和时间\n    struct tm tm = *localtime(&(time_t){time(NULL)});\n    printf("\\n今天是 :            %s", asctime(&tm));\n    printf("(夏令时 %s)\\n", tm.tm_isdst ? "生效中" : "未生效");\n \n    // 将月份减去 24，表示 24 个月前的日期和时间\n    tm.tm_mon -= 24;  \n \n    // 重新计算时间\n    mktime(&tm);       \n \n    // 获取并打印 24 个月前的日期和时间\n    printf("\\n24个月前的日期是 : %s", asctime(&tm));\n    printf("(夏令时 %s)\\n\\n", tm.tm_isdst ? "生效中" : "未生效");\n \n    return 0;\n} \n \n \n \n 5. \n #include <stdio.h>\n#include <limits.h>\n \ndouble powxn(double x, int n) {\n    double k;\n    if (n == 0) return 1;\n    k = powxn(x * x, n / 2);\n    if (n % 2) k = k * x;\n    return k;\n}\n \nint main(void)\n{\n    double x = 7.0;\n    int n = 2;\n    printf("\\nx = %f, y = %d  ", x, n);\n    printf("\\nResult:(x^n) : %f ",powxn(x, n));\n    x = 6.2;\n    n = 3;\n    printf("\\n\\nx = %f, y = %d  ", x, n);\n    printf("\\nResult:(x^n) : %f ",powxn(x, n));\n    return 0;\n}\n \n \n \n \n 6. \n //Source: https://bit.ly/2KNsta8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n \nchar* fractionToDecimal(int numerator, int denominator) {\n    char *p;\n    int psz, n, *dec, dsz, x;\n    long long num, den, k, f;\n    int i, repeat_at;\n    int neg = 0;\n \n    psz = dsz = 100; n = x = 0;\n    p = malloc(psz * sizeof(char));\n \n    neg = ((numerator > 0 && denominator < 0) ||\n           (numerator < 0 && denominator > 0)) ? 1 : 0;\n    num = numerator;\n    den = denominator;\n    num = (num < 0) ? -num : num;\n    den = (den < 0) ? -den : den;\n \n    k = num / den;\n    f = num % den;\n \n    if (neg && (k || f)) p[n ++] = \'-\';\n \n    n += sprintf(&p[n], "%lld", k);\n    if (!f) {\n        p[n] = 0;\n        return p;\n    }\n \n    p[n ++] = \'.\';\n \n    dec = malloc(dsz * sizeof(int));\n \n    repeat_at = -1;\n    if (f < 0) f = -f;\n    while (f) {\n        for (i = 0; i < x; i += 2) {\n            if (dec[i] == f) {\n                repeat_at = i;\n                goto done;\n            }\n        }\n        if (x + 1 >= dsz) {\n            dsz *= 2;\n            dec = realloc(dec, dsz * sizeof(int));\n        }\n        dec[x ++] = f;\n        f *= 10;\n        k = f / den;\n        dec[x ++] = k;\n        f = f % den;\n    }\n \ndone:\n    for (i = 0; i < x; i += 2) {\n        if (n + 3 > psz) {\n            psz *= 2;\n            p = realloc(p, psz * sizeof(char));\n        }\n        if (repeat_at == i) {\n            p[n ++] = \'(\';\n        }\n        p[n ++] = \'0\' + dec[i + 1];\n    }\n    if (repeat_at != -1) p[n ++] = \')\';\n    p[n ++] = 0;\n \n    free(dec);\n \n    return p;\n}\n \nint main(void)\n{\n    int n = 3;\n    int d = 2;\n    printf("\\nn = %d, d = %d  ", n, d);\n    printf("\\nFractional part: %s ", fractionToDecimal(n, d));\n \n    n = 4;\n    d = 7;\n    printf("\\n\\nn = %d, d = %d  ", n, d);\n    printf("\\nFractional part: %s ", fractionToDecimal(n, d));\n \n    return 0;\n} \n \n \n \n 7. \n #include <stdio.h>\n \nint main() {\n    int fno, sno, *ptr, *qtr, sum;  // 宣告整數變數 fno, sno, sum，以及整數指標 ptr, qtr\n \n    printf("\\n\\n Pointer : Add two numbers :\\n");\n    printf("--------------------------------\\n");\n \n    printf(" Input the first number : ");\n    // 檢查 scanf 的返回值，確保成功讀取一個整數\n    if (scanf("%d", &fno) != 1) {\n        fprintf(stderr, "Error: Invalid input for the first number.\\n");\n        return 1;\n    }\n \n    printf(" Input the second number : ");\n    // 檢查 scanf 的返回值，確保成功讀取一個整數\n    if (scanf("%d", &sno) != 1) {\n        fprintf(stderr, "Error: Invalid input for the second number.\\n");\n        return 1;\n    }\n \n    ptr = &fno;  // 將 fno 的地址賦值給指標 ptr\n    qtr = &sno;  // 將 sno 的地址賦值給指標 qtr\n \n    sum = *ptr + *qtr;  // 解參考 ptr 和 qtr，取得值並計算它們的和\n \n    printf(" The sum of the entered numbers is : %d\\n\\n", sum);  // 輸出輸入數字的總和\n \n    return 0;\n} \n \n \n \n 8. \n #include <stdio.h>\n \nint main() {\n    int arr[10];  // 宣告一個大小為10的整數數組，用於存儲使用者輸入的整數\n    int i;\n \n    // 提示用戶輸入十個整數\n    printf("\\n\\nRead and Print elements of an array:\\n");\n    printf("-----------------------------------------\\n");\n    printf("Input 10 elements in the array :\\n");\n \n    // 使用迴圈接受用戶輸入，並將整數存入數組\n    for (i = 0; i < 10; i++) {\n        printf("element - %d : ", i);\n \n        // 檢查 scanf 的返回值，確保成功讀取一個整數\n        if (scanf("%d", &arr[i]) != 1) {\n            fprintf(stderr, "Error: Invalid input for element %d.\\n", i);\n            return 1;  // 如果輸入無效，返回錯誤碼\n        }\n    }\n \n    // 顯示數組中的所有元素\n    printf("\\nElements in array are: ");\n    for (i = 0; i < 10; i++) {\n        printf("%d  ", arr[i]);\n    }\n \n    printf("\\n");\n    return 0;\n} \n \n \n \n 9. \n #include <stdio.h>\n \nint main() {\n    int days, years, weeks;\n \n    days = 1329; // 總天數\n \n    // 將天數轉換為年、週和天\n    years = days / 365;  // 計算年數\n    weeks = (days % 365) / 7;  // 計算週數\n    days = days % 7;  // 計算剩餘的天數\n \n    // 輸出結果\n    printf("Years: %d\\n", years);\n    printf("Weeks: %d\\n", weeks);\n    printf("Days: %d\\n", days);\n \n    return 0;\n} \n \n \n \n 10. \n #include <stdio.h>\n \nint main() {\n    double wi1, ci1, wi2, ci2, result; // 宣告變數，用於存儲物品的重量和數量\n \n    // 提示用戶輸入物品1的重量\n    printf("Weight - Item1: ");\n    if (scanf("%lf", &wi1) != 1) {\n        fprintf(stderr, "Error: Invalid input for weight of item1.\\n");\n        return 1;\n    }\n \n    // 提示用戶輸入物品1的數量\n    printf("No. of item1: ");\n    if (scanf("%lf", &ci1) != 1) {\n        fprintf(stderr, "Error: Invalid input for count of item1.\\n");\n        return 1;\n    }\n \n    // 提示用戶輸入物品2的重量\n    printf("Weight - Item2: ");\n    if (scanf("%lf", &wi2) != 1) {\n        fprintf(stderr, "Error: Invalid input for weight of item2.\\n");\n        return 1;\n    }\n \n    // 提示用戶輸入物品2的數量\n    printf("No. of item2: ");\n    if (scanf("%lf", &ci2) != 1) {\n        fprintf(stderr, "Error: Invalid input for count of item2.\\n");\n        return 1;\n    }\n \n    // 計算平均值\n    result = ((wi1 * ci1) + (wi2 * ci2)) / (ci1 + ci2);\n \n    // 輸出平均值\n    printf("Average Value = %f\\n", result);\n \n    return 0;\n} \n \n', 'tags': '', 'url': '課程2.html'}, {'title': '', 'text': '', 'tags': '', 'url': '.html'}, {'title': '練習2', 'text': '\n', 'tags': '', 'url': '練習2.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': '期末總結', 'text': '請各學員根據 課程內容 中的倉儲與網站評分項目, 自行評分.', 'tags': '', 'url': '期末總結.html'}]};